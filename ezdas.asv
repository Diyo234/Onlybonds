function [bfSIG,M] = ezdas(SIG,x,z,vsource,param) 
  
%EZDAS   Delay-And-Sum beamforming 
%   (Easy version of DAS) 
% 
%   BFSIG = EZDAS(SIG,X,Z,VSOURCE,PARAM) beamforms 
%   the RF or I/Q signals stored in the array SIG, 
%   and returns the beamformed signals BFSIG. The 
%   signals are beamformed at the points specified 
%   by X and Z. 
% 
%   1) SIG must be a 2-D array. The first dimension 
%      (i.e. each column) corresponds to single RF 
%      or I/Q signals over (fast-) time, with the 
%      1st column corresponding to the 1st element. 
%   2) VSOURCE contains the coordinates [x0,z0] of 
%      the virtual point source. Use large x0,z0 for 
%      plane waves. 
%   3) PARAM is a structure that contains the 
%      parameter values required for the delay-and- 
%      sum (see below for details). 
% 
%   Note: SIG must be complex for I/Q data 
%         (i.e. SIG = complex(I,Q) = I + 1i*Q). 
% 
%   [~,M] = EZDAS(...) also returns the DAS matrix. 
% 
%   PARAM must contain the following fields: 
%   --------------------------------------- 
%   1) PARAM.fs: sampling frequency (Hz) 
%   2) PARAM.pitch: element pitch (m) 
%   3) PARAM.fc: center frequency (Hz) 
%   4) PARAM.c: longitudinal velocity (m/s) 
%   5) PARAM.fnumber: receive f-number 
% 
%   --- 
%   NOTE #1: Interpolation method: EZDAS uses a 
%   linear interpolation to generate the DAS matrix. 
%   --- 
%   NOTE #2: EZDAS is for pedagogical purpose. Use 
%   DAS of the MUST toolbox for more options. 
%   --- 
% 
%   See also DAS, DASMTX. 
% 
%   -- Damien Garcia -- 2019/11 
%   www.biomecardio.com 
  
siz0 = size(x); 
[nl,nc] = size(SIG); 
x = x(:); z = z(:); 
 
% ULA (uniform linear array): 
% x-coordinates of the elements 
xe = ((0:nc-1)-(nc-1)/2)*param.pitch; 
L = xe(end)-xe(1); % length of the array 
 
% coordinates of the virtual source 
x0 = vsource(1); z0 = vsource(2); 
  
% transmit & receive distances 
dTX = hypot(x-x0,z-z0)-... 
    hypot((abs(x0)-L/2)*(abs(x0)>L/2),z0); 
dRX = hypot(x-xe,z); 
  
% two-way travel times 
tau = (dTX+dRX)/param.c; 
Perrot et al.   
 
11 
  
% fast-time indices 
idxt = tau*param.fs + 1; 
  
% boolean vectors 
I = idxt>=1 & idxt<=nl-1; 
Iaperture = abs(x-xe)<=(z/2/param.fnumber); 
I = I&Iaperture; 
  
% linear indices 
idx = idxt + (0:nc-1)*nl; 
idx = idx(I); 
idxf = floor(idx); 
idx = idxf-idx; 
  
% DAS matrix  
[i,~] = find(I); 
s = [idx+1;-idx]; % (for linear interpolation) 
if ~isreal(SIG) % if IQ: phase rotations 
    s = s.*exp(2i*pi*param.fc*[tau(I);tau(I)]); 
end 
M = sparse([i;i],[idxf;idxf+1],s,numel(x),nl*nc); 
  
% DAS beamforming 
bfSIG = reshape(M*SIG(:),siz0);